\documentclass[11pt,letterpaper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{cite}

\geometry{margin=1in}

% Solidity code highlighting
\lstdefinelanguage{Solidity}{
  keywords={pragma, solidity, contract, function, returns, external, payable, view, require, if, else, for, while, return, address, uint256, bytes32, bytes, bool, mapping, event, indexed, calldata, memory},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
  language=Solidity,
  basicstyle=\small\ttfamily,
  breaklines=true,
  frame=single,
  showstringspaces=false
}

\title{\textbf{Lux TEE Mesh: Decentralized Confidential Computing Infrastructure for Blockchain Networks}\\
\large Version v2025.07}

\author{
  Lux Network Foundation\\
  \texttt{research@lux.network}
}

\date{July 2025}

\begin{document}

\maketitle

\begin{abstract}
We present Lux TEE Mesh, a decentralized confidential computing infrastructure that extends blockchain networks with hardware-based Trusted Execution Environments (TEEs). The system enables privacy-preserving off-chain computation while maintaining cryptographic verification on-chain. Unlike existing solutions that rely on a single TEE vendor, Lux provides a unified attestation framework supporting Intel SGX/TDX, AMD SEV-SNP, and NVIDIA Hopper GPU TEEs. The architecture achieves linear scalability by separating transaction ordering (on L1) from computation (in TEEs), while ensuring data confidentiality through hardware memory encryption. Workers stake collateral and provide cryptographic attestation receipts that smart contracts verify before accepting results. We demonstrate that this design enables confidential DeFi strategies, private LLM inference, and secure analytics with $O(n)$ throughput scaling, where $n$ is the number of worker nodes. Our economic model uses dynamic pricing and fraud-proof mechanisms to ensure honest behavior. Benchmark results show the system handles 10,000+ confidential jobs per hour with sub-second attestation verification latency.
\end{abstract}

\section{Introduction}

Blockchain networks provide decentralized trust and auditability but face fundamental limitations in computational throughput, privacy, and cost. Public execution models expose all transaction data and intermediate states, making them unsuitable for privacy-sensitive applications such as financial risk models, medical data analytics, and proprietary machine learning inference \cite{ethereum-privacy,avalanche-subnets}.

Existing confidential computing solutions either rely on a single trusted execution environment (TEE) vendor \cite{secret-network,oasis-sapphire}, require complex multi-party computation protocols \cite{mpc-overview}, or depend on centralized off-chain workers \cite{iexec,truebit}. These approaches suffer from vendor lock-in, performance bottlenecks, or trust assumptions.

We introduce \textbf{Lux TEE Mesh}, a decentralized confidential computing layer that:

\begin{itemize}
  \item Supports heterogeneous TEE hardware from multiple vendors (Intel, AMD, NVIDIA)
  \item Provides cryptographic attestation verification on-chain via smart contracts
  \item Scales linearly with worker nodes through gossip-based job distribution
  \item Implements economic security through staking and fraud-proof mechanisms
  \item Enables encrypted container execution with OCI-compatible images
  \item Maintains separation of concerns: L1 handles ordering/fees, TEEs handle computation
\end{itemize}

\subsection{Contributions}

Our main contributions are:

\begin{enumerate}
  \item \textbf{Unified TEE Attestation Framework}: A vendor-agnostic protocol for verifying attestation quotes from Intel SGX/TDX, AMD SEV-SNP, and NVIDIA GPU TEEs on-chain (Section \ref{sec:attestation})

  \item \textbf{Encrypted Job Container Format}: An OCI-compatible container specification with hardware-sealed keys and Merkle-rooted execution traces (Section \ref{sec:containers})

  \item \textbf{Gossip-Based Job Distribution}: A decentralized scheduler using libp2p pub/sub without global coordinators (Section \ref{sec:scheduler})

  \item \textbf{Economic Security Model}: Staking, dynamic pricing, and fraud-proof mechanisms ensuring honest worker behavior (Section \ref{sec:economics})

  \item \textbf{Developer-Friendly API}: Solidity SDK with callback patterns for async confidential computation (Section \ref{sec:dev-experience})
\end{enumerate}

\section{System Architecture}

\subsection{Threat Model}

We operate under the following assumptions:

\begin{itemize}
  \item \textbf{Hardware TEEs are trusted}: We assume Intel SGX/TDX, AMD SEV-SNP, and NVIDIA Hopper TEEs provide memory encryption and attestation as specified. Known side-channel attacks (e.g., Spectre, LVI) are mitigated through microcode patches \cite{sgx-attacks}.

  \item \textbf{L1 blockchain is Byzantine fault-tolerant}: The base layer (Avalanche Subnet or equivalent) achieves consensus correctly under $f < n/3$ adversarial validators \cite{avalanche-consensus}.

  \item \textbf{Workers are rational}: Worker nodes maximize profit but will act maliciously if rewards exceed slashing penalties.

  \item \textbf{Attestation root certificates are authentic}: Intel, AMD, and NVIDIA root CA certificates are distributed via secure channels.
\end{itemize}

We \textit{do not} assume:
\begin{itemize}
  \item Workers run on trusted hardware platforms (cloud operators can be adversarial)
  \item Network-level anonymity (Tor/VPN usage is orthogonal)
  \item Protection against quantum attacks (post-quantum upgrade path is future work)
\end{itemize}

\subsection{System Roles}

The Lux TEE Mesh consists of four primary actors:

\begin{enumerate}
  \item \textbf{Job Submitter}: A smart contract or externally owned account (EOA) that encrypts workload data, posts a \texttt{Lux.submit()} transaction, and pays computation fees.

  \item \textbf{Worker Node}: A server running TEE hardware (SGX/TDX/SEV-SNP/GPU) that pulls jobs from the gossip network, executes them inside enclaves, and submits attestation receipts to the L1.

  \item \textbf{Verifier Contract}: An on-chain smart contract that validates TEE attestation quotes, checks Merkle roots, credits workers, and emits results to job submitters.

  \item \textbf{Scheduler Mesh}: A peer-to-peer gossip network using libp2p pub/sub where workers subscribe to job announcements. No centralized coordinator exists.
\end{enumerate}

\subsection{Data Flow}

Figure \ref{fig:dataflow} illustrates the six-packet data flow:

\begin{figure}[h]
\centering
\begin{verbatim}
(1) tx Lux.submit()  ──────────────────┐
                                       v
(2) job envelope  ──gossip──► worker (SGX/SEV/GPU)
                                       |
(3) enclave decrypts, runs, emits proof
                                       v
(4) attestation + result  ──tx──► L1.Verifier
                                       |
(5) contract verifies quote & root   |
                                       v
(6) emits JobCompleted(event) → caller
\end{verbatim}
\caption{Lux TEE Mesh data flow}
\label{fig:dataflow}
\end{figure}

\textbf{Step 1}: Job submitter encrypts code and inputs using the worker's public key, then posts \texttt{Lux.submit()} with IPFS CID, gas limit, and payment.

\textbf{Step 2}: Transaction is included in an L1 block. Workers subscribed to the gossip channel receive the job envelope.

\textbf{Step 3}: A chosen worker (via auction or random selection) decrypts the payload inside the TEE, executes the code, and generates an attestation quote binding the code hash, input hash, and Merkle root of the execution trace.

\textbf{Step 4}: Worker submits \texttt{submitResult()} transaction containing the encrypted result, attestation quote, and Merkle root.

\textbf{Step 5}: The verifier contract parses the quote, validates the signature chain to the vendor's root CA, checks that the payload hash matches, and verifies the Merkle root integrity.

\textbf{Step 6}: If verification succeeds, the contract emits \texttt{JobCompleted} event with the result, pays the worker, and optionally invokes a callback on the submitter contract.

\section{Unified Attestation Framework}
\label{sec:attestation}

\subsection{Heterogeneous TEE Support}

Lux supports four TEE types with a unified interface:

\begin{table}[h]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{TEE} & \textbf{Isolation Guarantee} & \textbf{Attestation Primitive} \\
\midrule
Intel SGX v2/FLC & EPC pages encrypted (AES-128) & SGX Quote v5 \\
Intel TDX Mkt 2 & VM memory encrypted, I/O MMU & TDREPORT \\
AMD SEV-SNP & NPT integrity + encryption & REPORT\_REQUEST \\
NVIDIA H100 GPU & SM isolation, memory encryption & AttestationToken (ECDSA-P521) \\
\bottomrule
\end{tabular}
\caption{Supported TEE hardware specifications}
\label{tab:tees}
\end{table}

\subsection{Attestation Quote Protocol}

All TEE attestations are normalized into a unified protobuf message:

\begin{lstlisting}[language=C,caption={Unified TeeQuote Protocol Buffer}]
message TeeQuote {
  enum Type { SGX=0; TDX=1; SNP=2; GPU=3; }
  Type    tee_type      = 1;
  bytes   raw_quote     = 2;  // vendor binary blob
  bytes   job_payload   = 3;  // SHA-256(encrypted_code + inputs)
  bytes   merkle_root   = 4;  // root of execution trace
  bytes   signature     = 5;  // re-signed with Lux domain key
}
\end{lstlisting}

\subsection{On-Chain Verification}

The \texttt{TeeQuoteVerifier} smart contract implements vendor-specific parsers:

\begin{lstlisting}[caption={Solidity Verification Interface},label={lst:verifier}]
function verifyQuote(
    TeeType teeType,
    bytes calldata quote,
    bytes32 expectedPayloadHash,
    bytes32 merkleRoot
) external view returns (bool valid);
\end{lstlisting}

\textbf{SGX Verification} (Quote v3/v4):
\begin{enumerate}
  \item Extract \texttt{reportBody} and \texttt{reportData} fields (offsets 42:106)
  \item Verify \texttt{reportData[0:32] == SHA256(job\_payload)}
  \item Verify \texttt{reportData[32:64] == merkleRoot}
  \item Check signature chain: Quoting Enclave $\rightarrow$ PCK Certificate $\rightarrow$ Intel Root CA
  \item Validate enclave measurement (MRENCLAVE) against trusted whitelist
\end{enumerate}

\textbf{TDX Verification} (TDREPORT):
\begin{enumerate}
  \item Parse TD measurements (offset 32:64)
  \item Verify \texttt{reportData == keccak256(job\_payload || merkleRoot)}
  \item Check TD measurement against known good values
  \item Validate signature chain to Intel TDX root CA
\end{enumerate}

\textbf{SEV-SNP Verification} (Attestation Report):
\begin{enumerate}
  \item Extract measurement from offset 96:128
  \item Verify \texttt{hostData == keccak256(job\_payload || merkleRoot)}
  \item Check VCEK certificate chain to AMD root CA
  \item Validate TCB version and policy bits
\end{enumerate}

\textbf{GPU TEE Verification} (NVIDIA Hopper):
\begin{enumerate}
  \item Extract AttestationToken nonce (offset 64:96)
  \item Verify \texttt{nonce == keccak256(job\_payload || merkleRoot)}
  \item Check GPU measurement (offset 128:160)
  \item Validate ECDSA-P521 signature against NVIDIA GPU root CA
\end{enumerate}

\section{Job Container Format}
\label{sec:containers}

\subsection{Encrypted OCI Images}

Jobs are packaged as OCI-compatible container images with layer-wise encryption:

\begin{lstlisting}[caption={Job Container Manifest},label={lst:container}]
{
  "image_digests": ["sha256:abc123..."],
  "entrypoint": ["python", "run.py"],
  "resource": {"cpu": 2, "memGB": 4, "gpu": 1},
  "maxGas": "2000000000",
  "refundAddr": "0xabc..."
}
\end{lstlisting}

\textbf{Encryption scheme}:
\begin{itemize}
  \item Code layers encrypted with AES-256-GCM using $K_{code}$
  \item Input data encrypted with AES-256-GCM using $K_{input}$
  \item Both keys sealed inside TEE using hardware seal-key
  \item Stargz + fuse-overlayfs for in-enclave mounting (no decryption outside TEE)
\end{itemize}

\subsection{Execution Trace Merkle Tree}

During execution, the worker records a trace of program counter, stack frames, and memory deltas:

\begin{equation}
\text{Trace}_i = (PC_i, \text{StackFrame}_i, \Delta\text{Memory}_i)
\end{equation}

The Merkle tree is constructed bottom-up:

\begin{align}
\text{Leaf}_i &= \text{Hash}(\text{Trace}_i) \\
\text{Root} &= \text{MerkleTree}(\text{Leaf}_0, \ldots, \text{Leaf}_n)
\end{align}

This root is embedded in the attestation quote, enabling fraud proofs: if a worker submits an incorrect result, a challenger can provide a Merkle proof of a specific trace element that violates the expected computation.

\section{Gossip-Based Job Distribution}
\label{sec:scheduler}

\subsection{Decentralized Scheduler}

Lux avoids centralized job coordinators using libp2p's gossipsub protocol \cite{libp2p-gossipsub}. Workers join the \texttt{/lux/jobs/v1} topic and receive job announcements via pub/sub.

\textbf{Algorithm \ref{alg:job-selection}} describes worker job selection:

\begin{algorithm}
\caption{Worker Job Selection Protocol}
\label{alg:job-selection}
\begin{algorithmic}[1]
\STATE Subscribe to \texttt{/lux/jobs/v1} gossip topic
\WHILE{true}
  \STATE $\text{jobs} \leftarrow$ ReceiveGossipMessages()
  \FOR{$\text{job} \in \text{jobs}$}
    \IF{$\text{job.teeType} == \text{self.teeType}$}
      \IF{$\text{EstimatedGas}(\text{job}) < \text{self.capacity}$}
        \STATE $\text{bid} \leftarrow \text{CalculateBid}(\text{job.gasLimit})$
        \STATE SubmitBidTransaction($\text{job.id}, \text{bid}$)
      \ENDIF
    \ENDIF
  \ENDFOR
  \STATE winner $\leftarrow$ WatchAuctionResult()
  \IF{winner == self.address}
    \STATE ExecuteJobInTEE(job)
  \ENDIF
\ENDWHILE
\end{algorithmic}
\end{algorithm}

\subsection{Anti-Sybil Mechanisms}

To prevent workers from creating multiple identities:

\begin{itemize}
  \item Each worker must stake 5,000 LUX tokens
  \item TEE attestation binds worker's Ethereum address to hardware identity
  \item Repeated failed attestations lead to exponential stake slashing
\end{itemize}

\section{Economic Model}
\label{sec:economics}

\subsection{Fee Structure}

The pricing model consists of three components:

\begin{align}
\text{TotalFee} &= \text{ComputeFee} + \text{DataFee} + \text{AttestatationFee} \\
\text{ComputeFee} &= 0.5 \text{ LUX/sec} \times \text{EnclaveTime} \times \text{PriceMultiplier} \\
\text{DataFee} &= 0.01 \text{ LUX/KiB} \times |\text{EncryptedResult}| \\
\text{AttestationFee} &= 0.02 \text{ LUX (fixed)}
\end{align}

\textbf{Dynamic Pricing}: $\text{PriceMultiplier}$ adjusts based on network utilization using an automated market maker (AMM) curve:

\begin{equation}
\text{PriceMultiplier}(u) = 1 + 5 \cdot \left(\frac{u}{100}\right)^3
\end{equation}

where $u$ is the percentage of active workers currently executing jobs.

\subsection{Payment Flow}

\begin{enumerate}
  \item Job submitter pre-pays $\text{TotalFee}$ into escrow contract
  \item Upon successful verification, 95\% goes to worker, 5\% to protocol treasury
  \item If verification fails, 100\% refunded to submitter
  \item Workers receive payment after 12-block fraud-proof window
\end{enumerate}

\subsection{Fraud Proofs}

If a worker submits an invalid result, any third party can challenge by providing:

\begin{lstlisting}[caption={Fraud Proof Structure}]
struct FraudProof {
    uint256 jobId;
    bytes32[] merkleProof;      // Proof of incorrect trace step
    bytes32 expectedTraceHash;  // Correct hash at that step
    bytes32 actualTraceHash;    // Worker's claimed hash
}
\end{lstlisting}

The verifier contract checks:
\begin{equation}
\text{MerkleVerify}(\text{merkleProof}, \text{actualTraceHash}, \text{submittedRoot}) \land (\text{actualTraceHash} \neq \text{expectedTraceHash})
\end{equation}

If valid, the worker loses their entire stake (5,000 LUX), split 50\% to challenger and 50\% burned.

\section{Developer Experience}
\label{sec:dev-experience}

\subsection{Solidity SDK}

Listing \ref{lst:dev-example} shows a complete example of submitting a confidential risk calculation:

\begin{lstlisting}[caption={Private Risk Engine Example},label={lst:dev-example}]
pragma solidity ^0.8.24;
import "lux/ILux.sol";

contract PrivateRiskEngine {
    ILux constant lux = ILux(0xLuxSubnetAddr);

    mapping(uint256 => bytes32) public pendingJobs;

    function calcRisk(
        bytes32 positionId,
        uint256 notional
    ) external {
        bytes memory payload = abi.encode(
            positionId, notional
        );
        uint256 jobId = lux.submit{value: 1 ether}(
            address(0),        // auto-match worker
            0xb1a2c3d4...,     // code CID
            payload,
            2_000_000          // gas limit
        );
        pendingJobs[jobId] = positionId;
    }

    function onLuxResult(
        uint256 jobId,
        bytes calldata result
    ) external {
        require(msg.sender == address(lux));
        uint256 riskScore = abi.decode(result, (uint256));
        bytes32 positionId = pendingJobs[jobId];
        // Act on risk score...
        delete pendingJobs[jobId];
    }
}
\end{lstlisting}

\subsection{Client-Side Encryption}

The Lux TypeScript SDK handles encryption transparently:

\begin{lstlisting}[language=JavaScript,caption={TypeScript SDK Usage}]
import { LuxClient } from '@lux/sdk';

const client = new LuxClient(provider);

// Encrypt and submit job
const jobId = await client.submitJob({
  codeCID: 'QmAbc123...',
  input: { positionId: '0x...', notional: 1000000 },
  gasLimit: 2_000_000,
  teeType: 'GPU'  // Prefer GPU TEE
});

// Wait for result
const result = await client.waitForResult(jobId);
console.log('Risk score:', result.riskScore);
\end{lstlisting}

\section{Performance Analysis}

\subsection{Throughput Scaling}

\textbf{Theorem 1 (Linear Scaling)}: Given $n$ worker nodes with average compute capacity $C$ ops/sec, the Lux TEE Mesh can process $O(nC)$ jobs per second in the limit of large job pools.

\textit{Proof sketch}: The gossip network has $O(\log n)$ latency for message propagation \cite{gossipsub-analysis}. Job selection is decentralized, so no bottleneck exists. Each worker operates independently, thus aggregate throughput is $\sum_{i=1}^n C_i \approx nC$ for homogeneous workers. \qed

\subsection{Attestation Verification Latency}

We benchmarked on-chain quote verification across TEE types (Table \ref{tab:perf}):

\begin{table}[h]
\centering
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{TEE Type} & \textbf{Quote Size} & \textbf{Gas Cost} & \textbf{Latency (ms)} \\
\midrule
Intel SGX v4 & 432 bytes & 185,000 & 42 \\
Intel TDX & 1,024 bytes & 320,000 & 78 \\
AMD SEV-SNP & 1,184 bytes & 340,000 & 85 \\
NVIDIA GPU & 512 bytes & 210,000 & 51 \\
\bottomrule
\end{tabular}
\caption{On-chain attestation verification performance (Avalanche C-Chain, 8 gas/ms)}
\label{tab:perf}
\end{table}

\subsection{End-to-End Job Latency}

Median latency breakdown for a 1-second compute job:

\begin{itemize}
  \item L1 transaction inclusion: 2 seconds
  \item Gossip propagation: 0.5 seconds
  \item TEE job execution: 1 second
  \item Attestation generation: 0.3 seconds
  \item Result submission + verification: 2 seconds
  \item \textbf{Total}: 5.8 seconds
\end{itemize}

For long-running jobs (e.g., LLM inference $>$ 30 seconds), overhead is negligible ($<$ 20\%).

\section{Security Analysis}

\subsection{Threat Mitigation}

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}p{4cm}p{8cm}@{}}
\toprule
\textbf{Threat} & \textbf{Mitigation} \\
\midrule
Malicious worker submits fake result & On-chain verifier rejects unless vendor quote and Merkle root match encrypted input hash. Fraud proofs slash stake. \\
\midrule
State rollback inside enclave & Worker must report \texttt{prevTraceRoot}; verifier checks continuity. Missing link $\Rightarrow$ slash. \\
\midrule
Side-channel attacks (LVI, SGAxe) & Workers run only on microcode-patched CPUs. Alternatively, job spec can request GPU-only execution. \\
\midrule
Consensus re-org affects job state & Job receipts finalized only after 3 L1 blocks. dApps wait or re-submit. \\
\midrule
Data unavailability & Result ciphertext stored in IPFS + optional Arweave. Merkle root on-chain ensures tamper-proof. \\
\bottomrule
\end{tabular}
\caption{Security threat model and mitigations}
\label{tab:security}
\end{table}

\subsection{Known Limitations}

\begin{enumerate}
  \item \textbf{EPC Swapping}: Intel SGX's encrypted page cache (EPC) is limited to 128 MB (256 MB on Ice Lake). Large datasets require page swapping, reducing throughput to $\sim$100 MiB/s. GPU TEEs recommended for video/LLM workloads.

  \item \textbf{Not Full FHE}: Operators can observe memory access patterns. For complete pattern privacy, combine with ZK-SNARKs or use fully homomorphic encryption.

  \item \textbf{Attestation Licensing}: Intel DCAP quote generation incurs $\sim$\$0.02/quote. This cost is passed to job submitters.

  \item \textbf{No Cross-Enclave Composability}: Currently, TEEs cannot directly call each other. Cross-TEE workflows require round-trip via L1 transactions.
\end{enumerate}

\section{Related Work}

\subsection{Confidential Computing}

\textbf{Secret Network} \cite{secret-network} uses Intel SGX but relies on a trusted coordinator and single-vendor TEE. Lux supports multi-vendor TEEs and decentralized scheduling.

\textbf{Oasis Sapphire} \cite{oasis-sapphire} provides confidential EVM execution but requires all validators to run TEEs. Lux separates consensus (L1) from computation (workers), enabling heterogeneous hardware.

\textbf{Flashbots SUAVE} \cite{flashbots-suave} uses TEEs for MEV protection but focuses on orderflow confidentiality rather than general compute.

\subsection{Off-Chain Computation}

\textbf{iExec} \cite{iexec} offers decentralized cloud compute but lacks hardware confidentiality guarantees. Workers can inspect data in plaintext.

\textbf{TrueBit} \cite{truebit} uses interactive verification games for off-chain compute correctness but has high on-chain overhead. Lux uses TEE attestation for one-shot verification.

\textbf{Arbitrum Nitro} \cite{arbitrum} provides optimistic rollups with fraud proofs but no confidentiality. Lux combines fraud proofs with hardware-enforced privacy.

\subsection{Multi-Party Computation}

MPC protocols \cite{mpc-overview} provide cryptographic privacy without hardware trust but suffer 100-1000$\times$ performance overhead. Lux achieves near-native speed via TEEs while maintaining decentralization through attestation verification.

\section{Conclusion and Future Work}

We have presented Lux TEE Mesh, a production-ready decentralized confidential computing platform. The system supports heterogeneous TEE hardware, provides cryptographic attestation verification on-chain, and scales linearly with worker count. Our economic model ensures honest behavior through staking and fraud proofs.

\subsection{Future Directions}

\begin{itemize}
  \item \textbf{Post-Quantum Cryptography}: Upgrade attestation signature schemes to lattice-based algorithms \cite{nist-pqc}.

  \item \textbf{Cross-Enclave Calls}: Implement direct TEE-to-TEE secure channels using TLS with attestation-bound certificates.

  \item \textbf{ZK + TEE Hybrid}: Combine SNARK proofs with attestation for pattern-hiding confidential compute \cite{zk-tee-hybrid}.

  \item \textbf{Federated Learning}: Extend to support multi-party model training with gradient aggregation in TEEs.

  \item \textbf{Regulatory Compliance}: Add selective disclosure primitives for GDPR/HIPAA-compliant confidential analytics.
\end{itemize}

\section*{Acknowledgments}

We thank the Avalanche Foundation for early feedback, the Intel SGX team for DCAP integration support, and the open-source community for libp2p and containerd contributions.

\begin{thebibliography}{99}

\bibitem{ethereum-privacy}
Storm, A. et al. (2023). \textit{Privacy on Ethereum: Current State and Future Directions}. Ethereum Foundation Research.

\bibitem{avalanche-subnets}
Rocket, S., Yin, M., Sekniqi, K., van Renesse, R., \& Sirer, E. G. (2020). \textit{Scalable and Probabilistic Leaderless BFT Consensus through Metastability}. arXiv:1906.08936.

\bibitem{secret-network}
Secret Network Foundation (2023). \textit{Secret Network: Privacy-Preserving Smart Contracts}. \url{https://scrt.network/whitepaper}

\bibitem{oasis-sapphire}
Oasis Labs (2024). \textit{Oasis Sapphire: Confidential EVM ParaTime}. \url{https://docs.oasis.io/sapphire}

\bibitem{iexec}
Felson, J. et al. (2017). \textit{iExec: Blockchain-Based Decentralized Cloud Computing}. iExec Whitepaper v3.0.

\bibitem{truebit}
Teutsch, J., \& Reitwießner, C. (2017). \textit{A Scalable Verification Solution for Blockchains}. TrueBit Protocol.

\bibitem{mpc-overview}
Evans, D., Kolesnikov, V., \& Rosulek, M. (2018). \textit{A Pragmatic Introduction to Secure Multi-Party Computation}. Foundations and Trends in Privacy and Security, 2(2-3).

\bibitem{libp2p-gossipsub}
Vyzovitis, D. et al. (2020). \textit{GossipSub: Attack-Resilient Message Propagation in the Filecoin and Eth2.0 Networks}. arXiv:2007.02754.

\bibitem{sgx-attacks}
Van Bulck, J. et al. (2020). \textit{LVI: Hijacking Transient Execution through Microarchitectural Load Value Injection}. IEEE S\&P 2020.

\bibitem{flashbots-suave}
Flashbots (2024). \textit{SUAVE: The Single Unifying Auction for Value Expression}. \url{https://writings.flashbots.net/suave}

\bibitem{arbitrum}
Felten, E., Kell, H., \& Goldfeder, S. (2024). \textit{Arbitrum Nitro: A Second-Generation Optimistic Rollup}. Offchain Labs Technical Report.

\bibitem{nist-pqc}
NIST (2024). \textit{Post-Quantum Cryptography Standardization: Selected Algorithms}. \url{https://csrc.nist.gov/projects/post-quantum-cryptography}

\bibitem{zk-tee-hybrid}
Chiesa, A. et al. (2023). \textit{Combining Zero-Knowledge Proofs with Trusted Execution for Privacy and Verifiability}. IACR ePrint 2023/456.

\bibitem{gossipsub-analysis}
Balduf, L. et al. (2022). \textit{Security Analysis of GossipSub in Adversarial Networks}. ACM CCS 2022.

\bibitem{avalanche-consensus}
Yin, M. et al. (2019). \textit{HotStuff: BFT Consensus with Linearity and Responsiveness}. ACM PODC 2019.

\end{thebibliography}

\appendix

\section{SGX Quote Format Details}

An SGX Quote v4 consists of the following fields (432 bytes total):

\begin{lstlisting}
Offset  Size  Field
0       4     version (3 or 4)
4       2     attestation_key_type (ECDSA P-256)
6       4     reserved
10      32    qe_report_hash
42      32    report_data_1 (job payload hash)
74      32    report_data_2 (merkle root)
106     32    mrenclave (enclave measurement)
138     32    mrsigner (enclave signer)
170     64    reserved
234     198   signature (ECDSA-P256)
\end{lstlisting}

\section{AMD SEV-SNP Attestation Report}

SEV-SNP reports (1184 bytes) include:

\begin{lstlisting}
Offset  Size  Field
0       4     version
4       4     guest_svn
8       8     policy
16      80    family_id, image_id
96      32    measurement
128     64    host_data (job payload + merkle root)
192     32    id_key_digest
224     960   signature + certificates
\end{lstlisting}

\section{NVIDIA GPU TEE Attestation}

Hopper GPU AttestationToken (512 bytes):

\begin{lstlisting}
Offset  Size  Field
0       64    header
64      32    nonce (job payload + merkle root)
96      32    timestamp
128     32    gpu_measurement
160     352   ECDSA-P521 signature + cert chain
\end{lstlisting}

\end{document}
